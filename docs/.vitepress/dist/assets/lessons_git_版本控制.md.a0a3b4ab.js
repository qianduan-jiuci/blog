import{_ as a,o as s,c as e,Q as t}from"./chunks/framework.7204edfa.js";const o="/blog/assets/1.b91c18cc.png",i="/blog/assets/2.94aff773.png",l="/blog/assets/3.aadfa7b8.png",n="/blog/assets/4.408ae0a8.png",p="/blog/assets/5.e3c19ad7.png",r="data:image/png;base64,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",c="/blog/assets/7.ac42d63b.png",g="/blog/assets/8.ee7b921c.png",d="/blog/assets/9.24b75109.png",h="/blog/assets/10.b3365e59.png",m="/blog/assets/11.5bb764a4.png",Q=JSON.parse('{"title":"初识Git","description":"","frontmatter":{},"headers":[],"relativePath":"lessons/git/版本控制.md","filePath":"lessons/git/版本控制.md","lastUpdated":1694323098000}'),u={name:"lessons/git/版本控制.md"},b=t(`<h1 id="初识git" tabindex="-1">初识Git <a class="header-anchor" href="#初识git" aria-label="Permalink to &quot;初识Git&quot;">​</a></h1><h2 id="集中式和分布式" tabindex="-1">集中式和分布式 <a class="header-anchor" href="#集中式和分布式" aria-label="Permalink to &quot;集中式和分布式&quot;">​</a></h2><p>集中式版本控制系统和分布式版本控制系统</p><p><code>集中式</code></p><p>集中式版本控制系统是将版本库集中存放于中央服务器，所有人共享这个服务器，每次干活的时候，都需要获取最新的代码，干完活之后，在上传自己最新的代码 举例： 类似于网络时代没有正式普及的时候的，交电费，以前的交电费是所有人去邮局交电费，如果交电费的人很多，再加上操作员的操作不熟练，速度是非常慢的。再比如医院挂号，以前就是排队去挂号。速度也是非常慢的 缺点： 如果网络不好或者没有网络，无法干活</p><p>SVN</p><p><code>分布式</code></p><p>分布式版本控制系统没有绝对的中央服务器，每个人的电脑都都有个版本库，在进行使用的时候，无需联网。 这样的话，相对于集中式版本控制系统，要安全的多，每个人的电脑上都有一个版本库，某个人的电脑出问题了，直接从其他人那里复制一份就行了。而集中式版本控制系统如果出问题了，那所有人都没法工作 在实际使用分布式的时候，很少在两个人对电脑上之间推送版本库的修改，因为俩人很有可能不在一个局域网内，两个电脑互相访问不了，因此，分布式中也有一个类似于“中央服务器”的电脑，它的作用只是方便大家交换版本库的修改，没有他也能干活，只是交换不方便而且</p><p>Git</p><p><code>区别</code></p><p>分布式每个人都能拷贝完整的代码，而分布式只能拷贝自己“需要的” 分布式的服务器挂了之后，不会影响工作，而集中式的服务器挂了之后，所有人都没法干活</p><h2 id="安装" tabindex="-1">安装 <a class="header-anchor" href="#安装" aria-label="Permalink to &quot;安装&quot;">​</a></h2><p><code>配置作者信息</code></p><p>git的这个命令行就相当于linux环境 简单的linux命令 mkdir cd ll ls pwd vim(vim文本编辑软件) subl(sublime文本编辑软件)</p><p><code>配置全局作者信息</code></p><p>先使用cd ，进入用户家目录</p><div class="language-tsx vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">tsx</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">git config </span><span style="color:#F97583;">--</span><span style="color:#E1E4E8;">global user.email </span><span style="color:#9ECBFF;">&quot;&quot;</span><span style="color:#E1E4E8;"> </span></span>
<span class="line"><span style="color:#E1E4E8;">git config </span><span style="color:#F97583;">--</span><span style="color:#E1E4E8;">global user.name </span><span style="color:#9ECBFF;">&quot;&quot;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">git config </span><span style="color:#D73A49;">--</span><span style="color:#24292E;">global user.email </span><span style="color:#032F62;">&quot;&quot;</span><span style="color:#24292E;"> </span></span>
<span class="line"><span style="color:#24292E;">git config </span><span style="color:#D73A49;">--</span><span style="color:#24292E;">global user.name </span><span style="color:#032F62;">&quot;&quot;</span></span></code></pre></div><p>这两个命令随便只要创建一个，就会生成一个.gitconfig配置文件 <img src="`+o+'" alt="image.png"> 使用vim或者subl可以查看配置文件，如果使用subl的时候无法打开sublime的话，需要在环境变量中配置sublime <img src="'+i+'" alt="image.png"></p><p>如果某个版本库没有配置作者信息的时候，就会默认使用全局作者信息</p><h2 id="配置局部作者信息" tabindex="-1">配置局部作者信息 <a class="header-anchor" href="#配置局部作者信息" aria-label="Permalink to &quot;配置局部作者信息&quot;">​</a></h2><p>git init: 相当于在本地创建一个版本仓库，会生成一个.git的目录，前面有.的表示隐藏目录 需要ls -a能查看到隐藏目录 <img src="'+l+`" alt="image.png"> 注意： d开头的是个文件夹，-开头的是个文件，我们可以使用subl打开 配置该仓库的作者信息 -- 打开 .git文件夹下面的config文件</p><div class="language-tsx vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">tsx</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">git config user.name </span><span style="color:#9ECBFF;">&quot;&quot;</span></span>
<span class="line"><span style="color:#E1E4E8;">git config user.email </span><span style="color:#9ECBFF;">&quot;&quot;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">git config user.name </span><span style="color:#032F62;">&quot;&quot;</span></span>
<span class="line"><span style="color:#24292E;">git config user.email </span><span style="color:#032F62;">&quot;&quot;</span></span></code></pre></div><p><img src="`+n+`" alt="image.png"></p><h1 id="维护旧项目和创建新项目" tabindex="-1">维护旧项目和创建新项目 <a class="header-anchor" href="#维护旧项目和创建新项目" aria-label="Permalink to &quot;维护旧项目和创建新项目&quot;">​</a></h1><p>维护旧项目的时候，须注意一点，不能在自己的仓库中克隆，在一个新目录，直接git clone就行</p><div class="language-tsx vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">tsx</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">git clone git@github.com:leeMarcus26</span><span style="color:#F97583;">/</span><span style="color:#E1E4E8;">lihaorun.git workspace</span></span>
<span class="line"><span style="color:#6A737D;">// 拷贝git@github.com:leeMarcus26/lihaorun.git仓库到本地的workspance文件夹</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">git clone git@github.com:leeMarcus26</span><span style="color:#D73A49;">/</span><span style="color:#24292E;">lihaorun.git workspace</span></span>
<span class="line"><span style="color:#6A737D;">// 拷贝git@github.com:leeMarcus26/lihaorun.git仓库到本地的workspance文件夹</span></span></code></pre></div><p>克隆的时候，会以项目的名称创建一个新文件夹 创建新项目： git init初始化一个新的仓库</p><h1 id="git流水线操作分析" tabindex="-1">git流水线操作分析 <a class="header-anchor" href="#git流水线操作分析" aria-label="Permalink to &quot;git流水线操作分析&quot;">​</a></h1><p><img src="`+p+'" alt="image.png"> 从生活中分析： 比如，我们的代码是成产衣服的车间，我们想要运输到仓库，需要一个小推车，通过小推车将所有的衣服一块运输到仓库 git也是，我们编辑的代码就相当于车间，需要将代码放入小推车中(add) ， 然后通过小推车运输到仓库(commit)。每次修改代码之后需要上传的内容，周而复始的重复工作 想要查看车间的状态(status)</p><h1 id="使用命令完成git流水线工作" tabindex="-1">使用命令完成git流水线工作 <a class="header-anchor" href="#使用命令完成git流水线工作" aria-label="Permalink to &quot;使用命令完成git流水线工作&quot;">​</a></h1><p>git init 初始化一个生产车间 git status 查看整个车间的一个状态 红色文件名表示，未被版本库管理，也就是一次也没有提交过的文件 git add a.js : 放入到我们的小推车里面(暂存区) | git add . : 将所有状态改变文件都放入小推车 git commit -m &quot;&quot;: 将小推车里面的东西存入仓库的时候，要填写的一些信息（干嘛用的）</p><p>注意： git add . 将所有状态发生改变文件都放入小推车，比如现在，有五十个文件，我只想把其中三是个文件放入小推车，这时候怎么办呢，就引出了下文的忽略文件</p><h1 id="gitignore详解版本库文件管理" tabindex="-1">.gitignore详解版本库文件管理 <a class="header-anchor" href="#gitignore详解版本库文件管理" aria-label="Permalink to &quot;.gitignore详解版本库文件管理&quot;">​</a></h1><p>.gitignore中配置忽略文件： 那些文件不放入到小推车</p><h2 id="忽略文件" tabindex="-1">忽略文件 <a class="header-anchor" href="#忽略文件" aria-label="Permalink to &quot;忽略文件&quot;">​</a></h2><p><img src="'+r+'" alt="image.png">含义表示，在检查状态的时候，会忽略掉a.txt *.txt : 忽略所有的txt文件 *.txt !a.txt : 忽略所有除去(a.txt)的txt文件</p><h2 id="忽略文件夹" tabindex="-1">忽略文件夹 <a class="header-anchor" href="#忽略文件夹" aria-label="Permalink to &quot;忽略文件夹&quot;">​</a></h2><p>在git中，如果一个文件夹中没有文件，不会追踪 <img src="'+c+'" alt="image.png"><img src="'+g+'" alt="image.png"> /node_modules: 表示忽略node_modules下的所有的文件 /node_modules/a.ts： 表示忽略node_modules下的a.ts文件 /node_modules/**/*.ts: 表示忽略node_modules及其子目录下的所有ts文件</p><h1 id="从版本库中删除资源" tabindex="-1">从版本库中删除资源 <a class="header-anchor" href="#从版本库中删除资源" aria-label="Permalink to &quot;从版本库中删除资源&quot;">​</a></h1><p>从版本库中删除某个资源使用 git rm fileName 大部分的情况是，版本库中的文件删除，在本地也会没有 但是有些情况是，我放错了，比如node_modules，放到版本库中没有什么意义的，但是在本地中不能删除，这时候，需要将版本库中的node_modules移除，本地保留 从版本中移除某个资源，但是本地依旧存在： git rm --cached fileName</p><p>注意： 从版本库中删除某个文件，会提交到暂存区，需要commit之后会在版本库中彻底删除</p><h1 id="从版本库中修改资料名称" tabindex="-1">从版本库中修改资料名称 <a class="header-anchor" href="#从版本库中修改资料名称" aria-label="Permalink to &quot;从版本库中修改资料名称&quot;">​</a></h1><p>修改名称：git mv a.txt b.txt: 将a.txt改为b.txt 有些文件名称的大小写改变，不会造成版本库的变化，我们可以使用mv进行操作 当然也还有另一种方法 比如： 我有一个indexControll.ts，想把这个文件改为IndexControll.ts，可以先将indexControll.ts改为abc, 再将abc改为IndexControl.ts</p><h1 id="使用log日志查看历史操作行为" tabindex="-1">使用log日志查看历史操作行为 <a class="header-anchor" href="#使用log日志查看历史操作行为" aria-label="Permalink to &quot;使用log日志查看历史操作行为&quot;">​</a></h1><p>git log查看日志信息 <img src="'+d+'" alt="image.png"></p><ul><li>commit后面的hash值表示每一次提交</li><li>Author表示作者</li><li>data表示提交的日期</li><li>abc.js 显示的是提交的描述</li></ul><p>git log -p 查看版本库的一个变动信息（显示内容更加全面） git log -p -1 查看版本库最新的变动信息 git log --oneline 查看版本库的简短信息 git log --oneline -p 查看版本库的简短变动信息 git log --name-only 查看文件的变化 git log --name-status 查看文件具体的变化(添加，修改， 删除) M: 修改 A： 添加</p><h1 id="使用amend修改最新一次提交事件" tabindex="-1">使用amend修改最新一次提交事件 <a class="header-anchor" href="#使用amend修改最新一次提交事件" aria-label="Permalink to &quot;使用amend修改最新一次提交事件&quot;">​</a></h1><p>git commit --amend ，修改最新一次提交 比如，刚刚我提交了一个文件到版本库，我感觉描述信息不太合合适，需要进行修改，可以使用amend进行修改 比如，我创建一个新的文件，需要提交到版本库，但是不想 在占用一个提交日志，我希望这个的提交，也在上次的提交日志中，这时候也可以和使用amend</p><h1 id="管理暂存区的文件" tabindex="-1">管理暂存区的文件 <a class="header-anchor" href="#管理暂存区的文件" aria-label="Permalink to &quot;管理暂存区的文件&quot;">​</a></h1><h2 id="撤销新文件添加到暂存区" tabindex="-1">撤销新文件添加到暂存区 <a class="header-anchor" href="#撤销新文件添加到暂存区" aria-label="Permalink to &quot;撤销新文件添加到暂存区&quot;">​</a></h2><p>git rm --cached fileName</p><h2 id="撤销文件的修改" tabindex="-1">撤销文件的修改 <a class="header-anchor" href="#撤销文件的修改" aria-label="Permalink to &quot;撤销文件的修改&quot;">​</a></h2><p>三个区分别对待</p><ol><li>之前已经提交到暂存区了，但是这次修改的还未放到暂存区，这时候可以使用git restore fileName 进行还原 2.之前已经提交到版本库了， 但是这次修改提交到暂存区 git restore --stage fileName: 恢复版本库中的暂存区文件 git resoter fileName : 目前的文件是不在暂存区的，使用该命令进行还原 3.之前已经提交到远程仓库了，但是这次修改提交到版本库了： git reset HEAD fileName</li></ol><h2 id="删除文件" tabindex="-1">删除文件 <a class="header-anchor" href="#删除文件" aria-label="Permalink to &quot;删除文件&quot;">​</a></h2><p>git rm --fileName删除暂存区和工作区, 提交到暂存区 git rm --cached fileName ，删除暂存区，不删除工作区</p><h1 id="alias命名别名" tabindex="-1">alias命名别名 <a class="header-anchor" href="#alias命名别名" aria-label="Permalink to &quot;alias命名别名&quot;">​</a></h1><p>git add git commit git log git restore 这些命令都是非常常用的命令，我不想打这么多单词，可以声明别名 在git config --global alias.a add : 表示给git add .定义别名a <img src="'+h+'" alt="image.png"><img src="'+m+'" alt="image.png"></p><h1 id="" tabindex="-1"><a class="header-anchor" href="#" aria-label="Permalink to &quot;&quot;">​</a></h1>',60),E=[b];function q(f,k,x,y,A,v){return s(),e("div",null,E)}const D=a(u,[["render",q]]);export{Q as __pageData,D as default};
