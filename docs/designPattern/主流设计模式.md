# 主流的设计模式

当前主流的二十三种设计模式可分为三大类: <h4>创建型模式 结构性模式 行为型模式</h4>
> 创建型模式： 如何创建对象
  - <strong>`单例模式`</strong>
  - `工厂方法模式`
  - `建造者模式`
  - 抽象工程模式
  - 原型模式
> 结构性模式： 如何将类或对象结合在一起形成一个更强大的结构
  - `适配器模式(类 / 对象)`
  - `代理模式`
  - `装饰器模式`
  - 组合模式
  - 享元模式
  - 外观模式
  - 桥接模式
> 行为型模式： 类和对象间如何交互，如何划分这则，从而更好的完成工作
  - `迭代器模式` 
  - `模板方法模式`
  - `策略模式`
  - `责任链模式`
  - `观察者模式`
  - 命令模式
  - 状态模式
  - 备忘录模式
  - 访问者模式
  - 中介者模式
  - 解释器模式


## 单例模式
单例模式是二十三种设计模式中最重要的一种设计模式

## 工厂方法模式

## 建造者模式

### 什么是建造者模式(生成器模式)

建造者模式是相对比较简单的一种设计模式，属于创建型模式的一种；定义：将一个复杂的对象分解成多个简单的对象来进行构建，将复杂的构建层与表现层分离，使相同的构建过程可以创建不同的表示模式。


简单例子来说：当我们在外面饭店吃饭时，比如点个水煮肉片，这家店可能会辣一点、那家店可能会咸一点、对面那家可能放青菜、隔壁那家可能放菠菜，每家店做出来的都不一样，明明都是水煮肉片却有不同的做法，如果都一样就不会说这家难吃那家好吃了。那再看KFC，我们点个汉堡，所有人不管在哪个城市哪家店，做法、味道都是一样的，为什么呢，因为它用料、时间、温度等等都是严格规定的，我们只需要下订单就行了，这就是一个建造者模式。

建造者模式是一步一步的创建一个复杂的对象，他允许用户只通过指定复杂的对象的类型和内容就可以创建，用户不用指定内部的构造细节


>建造者模式是将一个复杂对象的构建层和表示层相互分离，同样的构建过程可以采用不同的表示。与工厂模式相对应，工厂模式>主要是为了创建对象示例或者类簇（抽象工厂），关心的最终产出（创建）是什么，而可以不关注创建的过程，而建造者模式关>心的是创建对象的整个过程，甚至于创建对象的每一个细节


### 模式的结构

> - 产品（Product）

`它是包含多个组成部件的复杂对象，由具体建造者来创建其各个零部件。`

> - 建造者（Builder）

`定义了构建复杂对象的接口，声明了构建各个部分的方法,通常还包含一个返回复杂产品的方法 getResult()。`

> - 具体建造者 (Concrete Builder)

`实现了建造者实例，具体实现构建复杂对象各个部分的方法，返回最终构建的产品`

> - 指挥者 (Director)

`控制建造者的构建过程， 负责根据一定的逻辑顺序或逻辑组织建造者的方法调用，以构建特定的产品`

![结构流程图](/designPattern/主流的设计模式/image1.png)

### 模式的实现

```javascript
// 产品
class Car {
  constructor() {
    this.parts = [];
  }
  addPath(part) {
    this.parts.push(part);
  }
}
// 建造者
class Builder {
  constructor() {
    this.car = new Car();
  }
  // 添加引擎
  addEngine() {
    this.car.addPath("engine");
  }
  // 添加轮毂

  addTitel() {
    this.car.addPath("titel");
  }

  result() {
    return this.car;
  }
}

// 具体建造者
class ContrectBuilder {}
// 指挥者
class Director {
  constructor(builder) {
    this.builder = builder;
  }

  operator() {
    this.builder.addEngine();
    this.builder.addTitel();
  }
}

const dirctor = new Director(new Builder());
dirctor.operator();
console.log(dirctor.builder.result());
``` 

### 模式的应用

1. 使用场景

- 需要生成的对象具有复杂的内部结构时。
- 相同的方法，不同的执行顺序，产生不同的结果。
- 多个部件或零件，都可以装配到一个对象中，但是产生的结果又不相同。

2.优点    

- 封装性。是客户端不必知道产品内部组成的细节。
- 建造者独立，易扩展。
- 便于控制细节风险。可以对建造过程逐步细化，而不对其他模块产生任何影响。

3. 缺点

- 产品必须有共同点，范围有限制。
- 如果内部变化复杂，会有很多建造类。

## 抽象工程模式

## 原型模式

## 适配器模式(类 / 对象)

## 代理模式

## 装饰器模式

## 组合模式

## 享元模式

## 外观模式

## 桥接模式

## 迭代器模式

## 模板方法模式

## 策略模式

## 解释器模式

## 观察者模式

## 命令模式

## 状态模式

## 备忘录模式

## 访问者模式

## 中介者模式

## 解释器模式

