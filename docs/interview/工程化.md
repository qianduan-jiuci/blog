# 工程化

## 1. ES Module模块化的原理

当再浏览器环境中使用模块化的时候，是如何运作的

> 首先：模块解析
>
> 解析并不是执行，他会先将模块的路径进行补全，包括协议，域名，端口全都补全，然后会去下载这个模块，下载结束之后，他会拿到模块内部的代码，他会找到模块中所有的`顶级静态导入语句`，如果没有再顶级导入的话，浏览器会将静态导入语句进行提前。然后递归对直接或者间接导入的模块进行模块解析。

````js
import foo from './foo.js';
import bar from './bar.js';
import("./dynamic.js").then((m)=> {
    console.log('main', m.default);
} )

console.log('main', foo, bar)

````

````js
// foo.js
import bar from './bar.js';

console.log('foo',bar)

export default 'foo'
````

````js
// bar.js
console.log('bar', 'bar');
export default 'bar'
````



第二步：模块执行

这一步才会去真正的执行模块内部代码，浏览器针对导出的方式他是怎么处理的，它会在内部生成一个映射表，专门记录模块导出的内容`（作用是缓存）`，当在使用import foo from './foo.js';的时候，这个foo其实并不是简单的赋值，而是符号绑定：此时foo和default指向同一块内存空间，这种现象在js中绝无仅有。

| default | ‘bar' |
| ------- | ----- |
|         |       |
|         |       |

## 2. commonjs和ESM的区别

ESM是引用传递得，而commonJS导入的值为对象的拷贝（浅拷贝）