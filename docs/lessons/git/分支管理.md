# 分支管理
## 什么是分支
分支就类似于科幻电影的平行空间，当你在电脑上学习git， 另一个你在另一个平行空间里面学svn， 如果两个平行空间互不影响，，那对现在的你也没有影响，不够在某个时间电，两个平行宇宙合并了，结果，你既学会了git又学会了svn
![](/public/git/分支管理/1.png)
分支在实际开发中有什么用呢？ 假如你准备开发一个功能，但是需要两周才能完成，第一周你写了50%的代码，如果立刻提交，由于代码没写完，不完整的代码库导致别人也是无法干活，如果等代码全部写完再一次提交，又存在丢失每天进度的巨大风险。
现在有了分支，就不要担心这个问题了。你可以创建一个自己的分支，别人看不到你的代码，还可以在原来的分支上继续正常工作，而且在你的分支上工作，像提交就提交，知道开发完毕之后，在一次性的合并到原来的 分支上，这样，既安全，又不会影响别人工作。
其他的版本控制都有分支的概念，比如svn，但是用过之后，你会发现，这些版本控制创建分支和切换分支比蜗牛还慢，结果分支都成了摆设，大家都不去使用
但是git的分支，是与众不同的，无论创建，切换和删除分支，都能在1s之内完成，无论版本库中有一个文件还是一万个文件。
## 创建和合并分支原理
每次提交，git都会把他们串成一条时间线， 这个时间线就是一个分支。截至目前，只有一个分支，在这git里面，这个分支是主分支，即master分支。 HEAD，严格上来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指的就是当前分支

一开始的时候，master是一根线，git用master指向
的提交，再用HEAD指向master。就能确定当前分支，以及当前分支的一个提交点
![](/public/git/分支管理/2.png)
每次提交，master分支就会向前移动一步，这样，随着你不断提交，master分支线也就越长
![](/public/git/分支管理/3.png)

` 创建分支的原理`

当我们创建一个新的分支，例如dev时候，git新建一个指针，指向master相同的提交，再把HEAD指向master，就表示当前分支在dev
![](/public/git/分支管理/4.png)。
由此可以看出，git创建一个分支很快的原因： 除了增加一个指针，改改HEAD的指向，其他什么都没做。
不过现在开始，对工作区的提交和修改都是在dev分支上了，比如新的一次提交，dev指针就会往前一步，而master指针不变。
![](/public/git/分支管理/5.png)

` 合并分支的原理`

假如，我们在dev分支上的工作完成了，就额可以把dev合并到主分支上，git是如何进行合并呢？
最简单的方法，就是改变master指针的指向，让master指向dev的当前提交，就完成了合并
![](/public/git/分支管理/6.png)
所以git分支合并很快，就改改指针，工作内容都不变。合并完分支之后，甚至可以删除分支，其实就是删除指针
![](/public/git/分支管理/7.png)
## 代码指令实战

` 查看分支`

git branch 列出当前版本库的所有分支，*是一个指针，指针指向的分支，就是当前分支
git branch -a : 查看远程分支

` 创建分支`

git branch `<name> `
git branch dev  创建一个dev分支

`切换分支`

git checkout `<name> `
git checkout dev 切换到dev分支

`创建+切换分支`

git checkout  -b `<name>` 
git checkout -b bbs创建bbs分支，并且切换到bbs分支

`合并某分支到当前分支`

git merge `<name>`
例如： 合并dev分支到master
先切换到master分支， 然后使用git merge dev  合并dev分支到master分支
注意分支合并的时候有一个Fast-forward信息，git告诉我们，这次合并是快速合并，其实就是将master指针指向dev分支的当前提交，所以合并非常快速
当然，也不是每次合并都能fast-forward， 我们后面会讲到其他方式的合并

`删除分支`

git branch  -d `<name>`
git branch -d  dev 删除dev分支

`解决冲突`

git的冲突是指，某一个文件被多个分支占用，都修改过
冲突只能认为处理，系统不知道你想要哪个文件

## --merged 与--no-merged及分支强制删除操作
git branch --merged： 用来查看已经合并了的分支
![image.png](/public/git/分支管理/8.png)
git branch --no-merged: 用来查看没有合并了的分支
![image.png](/public/git/分支管理/9.png)
git如何判断该分支已经合并过了？
git在进行合并的时候其实就是改变指针的指向，所以判断的时候，也是判断分支和主分支的提交点是是否一样，
如果一样就证明提交过了，不一样就证明没有提交过

比如现在有一个test分支，做了一段时间发现需求不合理，没有存在的意义，我们想要使用git branch test -d将其删除, 发现删除不了，会把一个“当前分支没有合并，不能删除”的错误，可以将d改为D强制删除： git branch test -D
![image.png](/public/git/分支管理/10.png)
## 合并分支过程中产生的问题
比如目前，有两个分支dev和master

` dev分支上有commit， master分支上无commit`

上面再合并分支的时候，会显示一个fast-forward，这种合并分支是快速合并，其实上就是改变指针的指向，将主分支上的指针移动到dev分支的提交点，这其实上已经完成了合并
![image.png](/public/git/分支管理/11.png)
![image.png](/public/git/分支管理/12.png)

`dev分支上有commit，master上也有commit`

![image.png](/public/git/分支管理/13.png)
下面看一下git是如何进行这次分支的合并![image.png](/public/git/分支管理/14.png)
这时候会发现，合并的时候，同样会产生一个合并的日志信息

``时间线的问题``

这时候的合并上时间上不是一条直线，我们希望是一条时间线，看上去更直观一些

``合并冲突的问题``

在这种时候，合并的时候冲突了，是需要人为的进行解决冲突，这时候两个分支的负责人都可以去解决，但是
场景一： 

- 正常情况下，dev分支上的功能开发完毕了，dev去进行合并的时候，出现了冲突，肯定是希望dev去解决冲突。

场景二： 

- 尤其是在开源项目上更为明显，开源项目出现了问题，这时候游客A发现了问题，并去解决这个问题，解决完成之后，需要合并到master分支上，在合并的时候出现了合并冲突，如果希望作者去修改这个冲突的话， 那么作者还需要花费大量的时间和精力去阅读程序，这明显不合理，这种冲突也应该是游客A去解决

``解决问题``

这两种问题都可以使用rebase进行解决，rebase可以理解为replace base(改变基准电)
如果分支上面有commit， 主分支上没有commit，这个时候不会有合并记录，也不会有多条时间线
rebase的实现原理就是
第一步： 先隐藏子分支的提交记录
第二步:    把创建子分支时候的那个提交点往后移
第三步： 再把子分支的动作重新做一遍
原来是这样的一个时间线
![image.png](/public/git/分支管理/15.png)
使用rebase之后的时间线
![image.png](/public/git/分支管理/16.png)

指令操作：
git rebase `<branch>` 这个branch是分支，表示切换当前分支的基准点到指定分支最新提交点
